\documentclass[a4j]{jarticle}
\title{進化的アルゴリズム仮レポート \ 課題7}
\author{情報科学類, 3年, 2クラス, 学籍番号：201311403 \ 山岡 洸瑛, Yamaoka
Kouei}
\西暦
\date{2016年1月27日}

%余白設定
\setlength{\topmargin}{20mm}
\addtolength{\topmargin}{-1in}
\setlength{\oddsidemargin}{20mm}
\addtolength{\oddsidemargin}{-1in}
\setlength{\evensidemargin}{15mm}
\addtolength{\evensidemargin}{-1in}
\setlength{\textwidth}{170mm}
\setlength{\textheight}{254mm}
\setlength{\headsep}{0mm}
\setlength{\headheight}{0mm}
\setlength{\topskip}{0mm}


\def\pgfsysdriver{pgfsys-dvipdfmx.def}

\usepackage{ascmac}
\usepackage{here}
\usepackage{tikz}
\usetikzlibrary{trees}
\thispagestyle{empty}

\usepackage{listings,jlisting}
\renewcommand{\lstlistingname}{リスト}
\lstset{
basicstyle=\ttfamily\scriptsize,
commentstyle=\textit,
classoffset=1,
keywordstyle=\bfseries,
frame=tRBl,
framesep=5pt,
showstringspaces=false,
numbers=left,
stepnumber=1,
numberstyle=\tiny,
tabsize=2
}

\begin{document}
\maketitle

\section*{AS（Ant System）による巡回セールスマン問題の解決}
\section*{実験}
\subsection*{パラメータの決定}
巡回セールスマン問題eil51に対してパラメータ$\beta$の最適値を求める．その他のパラメータは与えられたものを使うため省略する．パラメータの調整は，乱数の初期値を変えて10回計算し，その結果を用いて行った．表\ref{beta}に$\beta$を2から5まで変えた時の順回路長（最良解）と反復回数の平均値と標準偏差を示す．表\ref{beta}より順回路長は$\beta=2$で最小になっているが，標準偏差が大きい．$\beta=3$としても順回路長はあまり変わらず，かつ標準偏差が小さくなるため，$\beta=3$とする．なお，シード値は{509, 521, 523, 541, 547, 557, 563, 569,571, 577}とした．
\begin{table}[H]
 \begin{center}
  \label{beta}
  \caption{各$\beta$毎の実験結果}
  \begin{tabular}[tb]{|c|c|c|c|c|}\hline
    &$ \beta = 2 $&$ \beta = 3 $&$ \beta = 4 $&$ \beta = 5 $\\\hline
巡回路長の平均 & 438 & 439 & 441 & 440 \\\hline
標準偏差 & 4.77 & 3.49 & 4.62 & 4.34 \\\hline
反復回数の平均 & 2006 & 1900 & 1710 & 1841 \\\hline
標準偏差 & 418.75 & 337.94 & 489.34 & 505.15 \\\hline
  \end{tabular}
 \end{center}
\end{table}

\par 以下にパラメータの一覧を示す．念の為，与えられた物も示した．
\begin{itemize}
 \item $\alpha = 1$
 \item $\beta = 3$
 \item アリの数$m$ = 都市数$n$
 \item $\rho = 0.5$
\end{itemize}

\subsection*{実験結果}
示したパラメータで実験を行った．その結果を表\ref{result}に示す．表には各問題を乱数の初期値を変えて10回行い，最良解の順回路長（括弧内は最適解）と反復回数の平均値と標準偏差を示している．また，順回路長については，標準偏差を平均値で割った変動係数も示した．これにより，大まかには全ての問題で標準偏差の大きさが揃っていると言える．

\begin{table}[H]
 \begin{center}
  \caption{実験結果}
  \label{result}
  \begin{tabular}[tb]{|c|c|c|c|c|c|} \hline
 & eil51 & pr76 & rat99 & kroA100 & ch130 \\\hline
巡回路長の平均 & 439（426） & 114921（108159） & 1266（1211） & 22495（21282） & 6473（6110） \\\hline
標準偏差 & 3.49 & 1061.45 & 7.28 & 58.16 & 53.55 \\\hline
変動係数 & 0.008 & 0.0092 & 0.0058 & 0.0026 & 0.0083 \\ \hline
反復回数の平均 & 1900 & 1757 & 1844 & 1988 & 1942 \\\hline
標準偏差 & 337.94 & 611.57 & 641.99 & 647.78 & 585.08 \\\hline
  \end{tabular}
 \end{center}
\end{table}

\subsection*{最良解の順回路長の推移}
各問題の最良解の順回路長の推移のグラフを図\ref{00}から図\ref{44}に示す．なお，シード値は10回の試行における最良解を出したものとした．

\subsubsection*{・eil51}
シード値は571．最適解426に対して，最良解は435．
\begin{figure}[H]
 \begin{center}
  \includegraphics[width=15cm, clip, bb=-75 0 442 266]{pic/00.jpg}
  \caption{eil51の最良解の推移}
  \label{00}
 \end{center}
\end{figure}
\clearpage
\subsubsection*{・pr76}
シード値は521．最適解108159に対して，最良解は112608．
\begin{figure}[H]
 \begin{center}
  \includegraphics[width=15cm, clip, bb=-75 0 455 266]{pic/11.jpg}
  \caption{pr76の最良解の推移}
  \label{11}
 \end{center}
\end{figure}
\subsubsection*{・rat99}
シード値は547．最適解1211に対して，最良解は1251．
\begin{figure}[H]
 \begin{center}
  \includegraphics[width=15cm, clip, bb=-75 0 441 265]{pic/22.jpg}
  \caption{rat99の最良解の推移}
  \label{22}
 \end{center}
\end{figure}
\clearpage
\subsubsection*{・kroA100}
シード値は577．最適解21282に対して，最良解は22411．
\begin{figure}[H]
 \begin{center}
  \includegraphics[width=15cm, clip, bb=-75 0 453 264]{pic/33.jpg}
  \caption{kroA100の最良解の推移}
  \label{33}
 \end{center}
\end{figure}
\subsubsection*{・ch130}
シード値は509．最適解6110に対して，最良解は6372．
\begin{figure}[H]
 \begin{center}
  \includegraphics[width=15cm, clip, bb=-75 0 447 266]{pic/44.jpg}
  \caption{ch130の最良解の推移}
  \label{44}
 \end{center}
\end{figure}




\subsection*{ソースコード}
リスト1にソースコードを示す．なお，変数宣言や，巡回セールスマン問題の読み込みなど，重要でないと思われる部分は省略している．
\begin{lstlisting}[caption=AS.c, label=AS, xleftmargin=1cm]
int main(int argc, char *argv[]){

  int eucArray[cityNum][cityNum];
  int check[m][cityNum]; // for check to passed city
  int solutions[m][cityNum];
  double tau[cityNum][cityNum]; // pheromone
  double p[m][cityNum]; // selection probability
  int tourLength[cityNum];
  int c1, c2; // selected city
  int bs = INT_MAX; // tour length @best solution

  // calc EUC_2D
  for(i=0; i<cityNum; i++){
    for(j=i+1; j<cityNum; j++){
      tmp = calcEuc(X[i], X[j], Y[i], Y[j]);
      eucArray[i][j] = tmp;
      eucArray[j][i] = tmp;
    }
  }

  // init pheromone
  // make solution by NN
  solutions[0][0] = 0; // start city 0
  check[0][0] = 1;
  min = 0;
  for(j=1; j<cityNum; j++){
    min = NNmethod(check[0], eucArray[min], cityNum); // find min EUC_2D
    check[0][min] = 1; // check city
    solutions[0][j] = min;
  }
  
  // clac tour length 
  sum = 0;
  for(i=0; i<cityNum; i++){ // calc link(c1, c2) length
    c1 = solutions[0][i]; 
    c2 = solutions[0][(i+1)%cityNum];
    sum += eucArray[c1][c2];
  }
  bs = sum;
  // set initial pheromone
  ftmp = m / sum;
  for(i=0; i<cityNum; i++){
    for(j=i+1; j<cityNum; j++){
      tau[i][j] = ftmp;
      tau[j][i] = ftmp;
    }
  }
  // end init pheromone
  
  // start iteration
  count = 0;
  loopcount = 0;
  while(1){
    loopcount++;
    for(i=0; i<m; i++){
      for(j=0; j<cityNum; j++){
        check[i][j] = 0;
      }
      tourLength[i] = 0;
    }
    // loop for ant
    for(ant=0; ant<m; ant++){
      c1 = cityNum * (rand()/(RAND_MAX+1.0)); // select first city
      check[ant][c1] = 1;
      solutions[ant][0] = c1;
      
      // loop for make tour
      for(city=1; city<cityNum; city++){
        // init
        sum = 0;
        for(i=0; i<m; i++){
          for(j=0; j<cityNum; j++){
            p[i][j] = 0;
          }
        }

        // calc selection probability ( p[][] )
        for(i=0; i<cityNum; i++){ // calc denominator
          if(check[ant][i] == 0){
            sum += pow(tau[c1][i], alpha) * pow((1.0 / eucArray[c1][i]), beta[b]);
          }
        }
        for(i=0; i<cityNum; i++){
          if(check[ant][i] == 0 && tau[c1][i] != 0){
            ftmp = pow(tau[c1][i], alpha) * pow((1.0 / eucArray[c1][i]), beta[b]) / sum;
            p[c1][i] = ftmp;
            p[i][c1] = ftmp;
            if(isnan(ftmp))
              ftmp = 1 / bs;
          }
        }
        // make selection probability array
        for(i=1; i<cityNum; i++){
          p[c1][i] += p[c1][i-1];
        }

        // select next city
        ftmp = p[c1][cityNum-1] * (rand()/(RAND_MAX+1.0));
        i = 0;
        while(1){
          if(p[c1][i] >= ftmp){
            c2 = i; // now c2 = the city next to c1
            check[ant][c2] = 1; // check
            solutions[ant][city] = c2; // input solution
            tourLength[ant] += eucArray[c1][c2]; // add length(c1, c2);
            c1 = c2;
            break;
          }
          i++;
        }
      }
      // end loop for make tour
      tourLength[ant] += eucArray[solutions[ant][0]][solutions[ant][cityNum-1]];
    }
    // end loop for ant
    
    // update pheromone
    // calc each tau according to ants
    // evaporation
    for(i=0; i<m; i++){
      for(j=0; j<cityNum; j++){
        tau[i][j] *= (1.0 - rho);
      }
    }
    // add pheromone
    for(ant=0; ant<m; ant++){
      ftmp = 1.0 / tourLength[ant];
      for(i=0; i<cityNum; i++){
        c1 = solutions[ant][i];
        c2 = solutions[ant][(i+1)%cityNum];
        tau[c1][c2] += ftmp;
        tau[c2][c1] += ftmp;
      }
    }
    // end update pheromone

    // search min
    min = INT_MAX;
    for(i=0; i<cityNum; i++){
      if(min > tourLength[i]){
        min = tourLength[i];
        minNum = i;
      }
    }

    // end decision
    if(bs < min){ // continue 
      count++;
    }
    else{ // update best solution, reset count and continue
      bs = min;
      count = 0;
    }
    if(count == maxloop){// end
      break;
    }
  }
  return 0;
}
int NNmethod(int *c, int *euc, int num){
  int i, minNum;
  int m = INT_MAX;
  for(i=0; i<num; i++){
    if(*c == 0 && *euc != 0 && m > *euc){ // if (not checked and not 0 and min)
      m = *euc;
      minNum = i;
    }
    if(i<num-1){
      ++c;
      ++euc;
    }
  }
  return minNum;
}
int calcEuc(double x1, double x2, double y1, double y2){
  return (int)(sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2)) + 0.5);   
}
\end{lstlisting}


\end{document}
